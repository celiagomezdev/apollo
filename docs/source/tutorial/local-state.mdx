---
title: 'Manage local state'
sidebar_title: '9. Manage local state'
description: Store and query local data in the Apollo cache
---

import { MultiCodeBlock } from 'gatsby-theme-apollo-docs';
import Disclaimer from '../../shared/disclaimer.mdx';

Time to accomplish: _15 Minutes_

Most web apps rely on a combination of remotely fetched data and locally stored data. We can use Apollo Client to manage _both_ types of data, making it a single source of truth for our application's state. We can even interact with both types of data in a single operation. Let's learn how!

<Disclaimer />

## Define a client-side schema

First, let's define a **client-side GraphQL schema** that's specific to our application client. This isn't _required_ for managing local state, but it enables useful developer tooling and helps us reason about our data.

Add the following definition to `src/index.tsx`:

<MultiCodeBlock>

```tsx:title=src/index.tsx
export const typeDefs = gql`
  extend type Query {
    isLoggedIn: Boolean!
    cartItems: [ID!]!
  }
`;
```

</MultiCodeBlock>

As you might expect, this looks a lot like a definition from our _server's_ schema, with one difference: we **extend** the `Query` type. You can extend a GraphQL type that's defined in another location to add fields to that type.

In this case, we're adding two fields to `Query`:

* `isLoggedIn`, to track whether the user has an active session
* `cartItems`, to track which launches the user has added to their cart

Also modify the constructor of `ApolloClient` to provide your client-side schema:

<MultiCodeBlock>

```ts:title=src/index.tsx
const client: ApolloClient<NormalizedCacheObject> = new ApolloClient({
  cache,
  uri: 'http://localhost:4000/graphql',
  headers: {
    authorization: localStorage.getItem('token') || '',
  },
  typeDefs, // highlight-line
});
```

</MultiCodeBlock>

Next, we need to define how we store the values of these local fields on the client.

## Initialize reactive variables

Just like on the server, we can populate client-side schema fields with data from any source we want. Apollo Client provides a couple of useful built-in options for this:

* The same in-memory cache where all data from remote queries is stored
* **Reactive variables**, which can store arbitrary data _outside_ the cache while still updating queries that depend on them

Both of these options work for most use cases. We'll use reactive variables because they're faster to get started with.

Open `src/cache.ts`. Update its `import` statement to include the `makeVar` function:

```js:title=src/cache.ts
import { InMemoryCache, Reference, makeVar } from '@apollo/client';
```

Then, add the following to the bottom of the file:

<MultiCodeBlock>

```ts:title=src/cache.ts
// Initializes to true if localStorage includes a 'token' key,
// false otherwise
export const isLoggedInVar = cache.makeVar<boolean>(!!localStorage.getItem('token'));

// Initializes to an empty array
export const cartItemsVar = cache.makeVar<string[]>([]);
```

</MultiCodeBlock>

Here we define two reactive variables, one for each of our client-side schema fields. The value we provide to each `makeVar` call sets the variable's initial value.

The values of `isLoggedInVar` and `cartItemsVar` are  _functions_:

* If you call a reactive variable function with zero arguments (e.g., `isLoggedInVar()`), it returns the variable's current value.
* If you call the function with _one_ argument (e.g., `isLoggedInVar(false)`), it _replaces_ the variable's current value with the provided value.

We now have our client-side schema and our client-side data sources. On the server side, next we would define resolvers to connect the two. On the client side, however, we define **field policies** instead.

## Define client-side field policies

A field policy specifies how a single GraphQL field in the Apollo Client cache is read and written. Most server-side schema fields don't need a field policy, because the default policy does the right thing: it writes query results directly to the cache and returns those results without any modifications.

However, our client-side fields aren't _stored_ in the cache! We need to define field policies to tell Apollo Client how to query those fields.

In `src/cache.ts`, look at the constructor of `InMemoryCache`:

<MultiCodeBlock>

```ts:title=src/cache.ts
export const cache: InMemoryCache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        launches: {
          // ...field policy definitions...
        }
      }
    }
  }
});
```

</MultiCodeBlock>

You might remember that we've _already_ defined a field policy here, specifically for the `Query.launches` field when we [added pagination support](./queries/#add-pagination-support) to our `GET_LAUNCHES` query.

Let's add field policies for `Query.isLoggedIn` and `Query.cartItems`:

<MultiCodeBlock>

```ts{5-14}:title=src/cache.ts
export const cache: InMemoryCache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        isLoggedIn: {
          read() {
            return isLoggedInVar();
          } 
        },
        cartItems: {
          read() {
            return cartItemsVar();
          } 
        },
        launches: {
          // ...field policy definitions...
        }
      }
    }
  }
});
```

</MultiCodeBlock>

Our two field policies each include a single field: a **`read` function**. Apollo Client calls a field's `read` function whenever that field is queried. The query result uses the function's return value as the _field's_ value, regardless of any value in the cache or on your GraphQL server.

Now, whenever we query one of our client-side schema fields, the value of our corresponding reactive variable is returned. Let's write a query to try it!

## Query local fields

You can include client-side fields in any GraphQL query you write. To do so, you add the `@client` directive to every client-side field in your query. This tells Apollo Client _not_ to fetch that field's value from your server.

### Login status

Let's define a query that includes our new `isLoggedIn` field. Add the following definitions to `index.tsx`:

<MultiCodeBlock>

```tsx:title=src/index.tsx
const IS_LOGGED_IN = gql`
  query IsUserLoggedIn {
    isLoggedIn @client
  }
`;

function IsLoggedIn() {
  const { data } = useQuery(IS_LOGGED_IN);
  return data.isLoggedIn ? <Pages /> : <Login />;
}
```

</MultiCodeBlock>

The `isLoggedIn` component executes the `IS_LOGGED_IN` query:

* If the user _isn't_ logged in, the component displays our application's login screen.
* Otherwise, the component displays our application's home page.

Because all of this query's fields are local fields, we don't need to worry about displaying any loading state.

### Cart items

Let's look at another example of a component that queries local state in `src/pages/cart.tsx`. Just like before, we create our query:

<MultiCodeBlock>

```tsx:title=src/pages/cart.tsx
import React, { Fragment } from 'react'; // preserve-line
import { gql, useQuery } from '@apollo/client'; // preserve-line

import { Header, Loading } from '../components'; // preserve-line
import { CartItem, BookTrips } from '../containers'; // preserve-line
import { RouteComponentProps } from '@reach/router';
import * as GetCartItemsTypes from './__generated__/GetCartItems';

export const GET_CART_ITEMS = gql`
  query GetCartItems {
    cartItems @client
  }
`;
```

</MultiCodeBlock>

Next, we call `useQuery` and bind it to our `GetCartItems` query:

<MultiCodeBlock>

```tsx:title=src/pages/cart.tsx
interface CartProps extends RouteComponentProps {}

const Cart: React.FC<CartProps> = () => {
  const { data, loading, error } = useQuery<
    GetCartItemsTypes.GetCartItems
  >(GET_CART_ITEMS);

  if (loading) return <Loading />;
  if (error) return <p>ERROR: {error.message}</p>;

  return (
    <Fragment>
      <Header>My Cart</Header>
      {!data || !!data && data.cartItems.length === 0 ? (
        <p data-testid="empty-message">No items in your cart</p>
      ) : (
        <Fragment>
          {!!data && data.cartItems.map((launchId: any) => (
            <CartItem key={launchId} launchId={launchId} />
          ))}
          <BookTrips cartItems={!!data ? data.cartItems : []} />
        </Fragment>
      )}
    </Fragment>
  );
}

export default Cart;
```

</MultiCodeBlock>

It's important to note that you can mix local queries with remote queries in a single GraphQL document. Now that you're a pro at querying local data with GraphQL, let's learn how to add local fields to server data.

### Adding virtual fields to server data

One of the unique advantages of managing your local data with Apollo Client is that you can add **virtual fields** to data you receive back from your graph API. These fields only exist on the client and are useful for decorating server data with local state. In our example, we're going to add an `isInCart` virtual field to our `Launch` type.

To add a virtual field, first extend the type of the data you're adding the field to in your client schema. Here, we're extending the `Launch` type:

<MultiCodeBlock>

```ts:title=src/resolvers.tsx
import { gql } from '@apollo/client';

export const schema = gql`
  extend type Launch {
    isInCart: Boolean!
  }
`;
```

</MultiCodeBlock>

Next, specify a client resolver on the `Launch` type to tell Apollo Client how to resolve your virtual field:

<MultiCodeBlock>

```tsx:title=src/resolvers.tsx
// previous imports
import { GET_CART_ITEMS } from './pages/cart';

// type defs and other previous variable declarations

interface AppResolvers extends Resolvers {
  Launch: ResolverMap; // highlight-line
}

export const resolvers: AppResolvers = { // highlight-line
  Launch: {
    isInCart: (launch: LaunchTileTypes.LaunchTile, _, { cache }): boolean => {
      const queryResult = cache.readQuery<GetCartItemTypes.GetCartItems>({
        query: GET_CART_ITEMS
      });
      if (queryResult) {
        return queryResult.cartItems.includes(launch.id)
      }
      return false;
    }
  },
};
```

</MultiCodeBlock>

We're going to learn more about client resolvers in the section below. The important thing to note is that the resolver API on the client is the same as the resolver API on the server.

Now, you're ready to query your virtual field on the launch detail page! Similar to the previous examples, just add your virtual field to a query and specify the `@client` directive.

<MultiCodeBlock>

```tsx{4}:title=src/pages/launch.tsx
export const GET_LAUNCH_DETAILS = gql`
  query LaunchDetails($launchId: ID!) {
    launch(id: $launchId) {
      isInCart @client
      site
      rocket {
        type
      }
      ...LaunchTile
    }
  }
  ${LAUNCH_TILE_DATA}
`;
```

</MultiCodeBlock>

## Update local data

Up until now, we've focused on querying local data from the Apollo cache. Apollo Client also lets you update local data in the cache with either **direct cache writes** or **client resolvers**. Direct writes are typically used to write simple booleans or strings to the cache whereas client resolvers are for more complicated writes such as adding or removing data from a list.

### Direct cache writes

Direct cache writes are convenient when you want to write a simple field, like a boolean or a string, to the Apollo cache. We perform a direct write by calling `client.writeData()` and passing in an object with a data property that corresponds to the data we want to write to the cache. We've already seen an example of a direct write, when we called `client.writeData` in the `onCompleted` handler for the login `useMutation` based component. Let's look at a similar example, where we copy the code below to create a logout button:

<MultiCodeBlock>

```tsx:title=src/containers/logout-button.tsx
import React from 'react';
import styled from 'react-emotion';
import { useApolloClient } from '@apollo/client';

import { menuItemClassName } from '../components/menu-item';
import { ReactComponent as ExitIcon } from '../assets/icons/exit.svg';

export default function LogoutButton() {
  const client = useApolloClient();
  return (
    <StyledButton
      onClick={() => {
        client.writeData({ data: { isLoggedIn: false } }); // highlight-line
        localStorage.clear();
      }}
    >
      <ExitIcon />
      Logout
    </StyledButton>
  );
}

const StyledButton = styled('button')(menuItemClassName, {
  background: 'none',
  border: 'none',
  padding: 0,
});
```

</MultiCodeBlock>

When we click the button, we perform a direct cache write by calling `client.writeData` and passing in a data object that sets the `isLoggedIn` boolean to false.

We can also perform direct writes within the `update` function of the `useMutation` hook. The `update` function allows us to manually update the cache after a mutation occurs without refetching data. Let's look at an example in `src/containers/book-trips.tsx`:

<MultiCodeBlock>

<!-- TODO: make this more brief after a fix lands -->

```tsx{38-40}:title=src/containers/book-trips.tsx
import React from 'react'; // preserve-line
import { gql, useMutation } from '@apollo/client'; // preserve-line

import Button from '../components/button'; // preserve-line
import { GET_LAUNCH } from './cart-item'; // preserve-line
import * as GetCartItemsTypes from '../pages/__generated__/GetCartItems';
import * as BookTripsTypes from './__generated__/BookTrips';

export const BOOK_TRIPS = gql`
  mutation BookTrips($launchIds: [ID]!) {
    bookTrips(launchIds: $launchIds) {
      success
      message
      launches {
        id
        isBooked
      }
    }
  }
`;

interface BookTripsProps extends GetCartItemsTypes.GetCartItems {}

const BookTrips: React.FC<BookTripsProps> = ({ cartItems }) => {
  const [
    bookTrips, { data }
  ] = useMutation<
    BookTripsTypes.BookTrips,
    BookTripsTypes.BookTripsVariables
  > (
    BOOK_TRIPS,
    {
      variables: { launchIds: cartItems },
      refetchQueries: cartItems.map(launchId => ({
        query: GET_LAUNCH,
        variables: { launchId },
      })),
      update(cache) {
        cache.writeData({ data: { cartItems: [] } });
      }
    }
  );

  return data && data.bookTrips && !data.bookTrips.success
    ? <p data-testid="message">{data.bookTrips.message}</p>
    : (
      <Button
        onClick={() => bookTrips()}
        data-testid="book-button">
        Book All
      </Button>
    );
}

export default BookTrips;
```

```jsx:title=src/containers/book-trips.jsx
import React from 'react'; // preserve-line
import { gql, useMutation } from '@apollo/client'; // preserve-line

import Button from '../components/button'; // preserve-line
import { GET_LAUNCH } from './cart-item'; // preserve-line
import * as GetCartItemsTypes from '../pages/__generated__/GetCartItems';
import * as BookTripsTypes from './__generated__/BookTrips';

export const BOOK_TRIPS = gql`
  mutation BookTrips($launchIds: [ID]!) {
    bookTrips(launchIds: $launchIds) {
      success
      message
      launches {
        id
        isBooked
      }
    }
  }
`;

interface BookTripsProps extends GetCartItemsTypes.GetCartItems {}

const BookTrips: React.FC<BookTripsProps> = ({ cartItems }) => {
  const [
    bookTrips, { data }
  ] = useMutation<
    BookTripsTypes.BookTrips,
    BookTripsTypes.BookTripsVariables
  > (
    BOOK_TRIPS,
    {
      variables: { launchIds: cartItems },
      refetchQueries: cartItems.map(launchId => ({
        query: GET_LAUNCH,
        variables: { launchId },
      })),
      update(cache) { // highlight-line
        cache.writeData({ data: { cartItems: [] } }); // highlight-line
      } // highlight-line
    }
  );

  return data && data.bookTrips && !data.bookTrips.success
    ? <p data-testid="message">{data.bookTrips.message}</p>
    : (
      <Button
        onClick={() => bookTrips()}
        data-testid="book-button">
        Book All
      </Button>
    );
}

export default BookTrips;
```

</MultiCodeBlock>

In this example, we're directly calling `cache.writeData` to reset the state of the `cartItems` after the `BookTrips` mutation is sent to the server. This direct write is performed inside of the update function, which is passed our Apollo Client instance.

### Local resolvers

We're not done yet! What if we wanted to perform a more complicated local data update such as adding or removing items from a list? For this situation, we'll use a local resolver. Local resolvers have the same function signature as remote resolvers (`(parent, args, context, info) => data`). The only difference is that the Apollo cache is already added to the context for you. Inside your resolver, you'll use the cache to read and write data.

Let's write the local resolver for the `addOrRemoveFromCart` mutation. You should place this resolver underneath the `Launch` resolver we wrote earlier.

<MultiCodeBlock>

```tsx:title=src/resolvers.tsx
interface AppResolvers extends Resolvers {
  Launch: ResolverMap;
  Mutation: ResolverMap; // highlight-line
}

export const resolvers = {
  Mutation: {
    addOrRemoveFromCart: (_, { id }: { id: string }, { cache }): string[] => {
      const queryResult = cache
        .readQuery<GetCartItemTypes.GetCartItems, any>({
          query: GET_CART_ITEMS
        });
      if (queryResult) {
        const { cartItems } = queryResult;
        const data = {
          cartItems: cartItems.includes(id)
            ? cartItems.filter((i) => i !== id)
            : [...cartItems, id],
        };
        cache.writeQuery({ query: GET_CART_ITEMS, data });
        return data.cartItems;
      }
      return [];
    },
  },
};
```

</MultiCodeBlock>

In this resolver, we destructure the Apollo `cache` from the context in order to read the query that fetches cart items. Once we have our cart data, we either remove or add the cart item's `id` passed into the mutation to the list. Finally, we return the updated list from the mutation.

Let's see how we call the `addOrRemoveFromCart` mutation in a component:

<MultiCodeBlock>

```tsx:title=src/containers/action-button.tsx
import { gql } from '@apollo/client';

const TOGGLE_CART = gql`
  mutation addOrRemoveFromCart($launchId: ID!) {
    addOrRemoveFromCart(id: $launchId) @client
  }
`;
```

</MultiCodeBlock>

Just like before, the only thing we need to add to our mutation is a `@client` directive to tell Apollo to resolve this mutation from the cache instead of a remote server.

Now that our local mutation is complete, let's build out the rest of the `ActionButton` component so we can finish building the cart:

<MultiCodeBlock>

```tsx:title=src/containers/action-button.tsx
import React from 'react';
import { gql, useMutation } from '@apollo/client';

import { GET_LAUNCH_DETAILS } from '../pages/launch';
import Button from '../components/button';
import * as LaunchDetailTypes from '../pages/__generated__/LaunchDetails';

export const TOGGLE_CART = gql`
  mutation addOrRemoveFromCart($launchId: ID!) {
    addOrRemoveFromCart(id: $launchId) @client
  }
`;

export const CANCEL_TRIP = gql`
  mutation cancel($launchId: ID!) {
    cancelTrip(launchId: $launchId) {
      success
      message
      launches {
        id
        isBooked
      }
    }
  }
`;

interface ActionButtonProps extends Partial<LaunchDetailTypes.LaunchDetails_launch> {}

const ActionButton: React.FC<ActionButtonProps> = ({ isBooked, id, isInCart }) => {
  const [mutate, { loading, error }] = useMutation(
    isBooked ? CANCEL_TRIP : TOGGLE_CART,
    {
      variables: { launchId: id },
      refetchQueries: [
        {
          query: GET_LAUNCH_DETAILS,
          variables: { launchId: id },
        },
      ]
    }
  );

  if (loading) return <p>Loading...</p>;
  if (error) return <p>An error occurred</p>;

  return (
    <div>
      <Button
        onClick={() => mutate()}
        data-testid={'action-button'}
      >
        {isBooked
          ? 'Cancel This Trip'
          : isInCart
            ? 'Remove from Cart'
            : 'Add to Cart'}
      </Button>
    </div>
  );
}

export default ActionButton;
```

</MultiCodeBlock>

In this example, we're using the `isBooked` prop passed into the component to determine which mutation we should fire. Just like remote mutations, we can pass in our local mutations to the same `useMutation` hook.

---

Congratulations! 🎉 You've officially made it to the end of the Apollo platform tutorial. In the final section, we're going to recap what we just learned and give you guidance on what you should learn next.
